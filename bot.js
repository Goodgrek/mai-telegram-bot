const { Telegraf } = require('telegraf');
const { message } = require('telegraf/filters');
const { Pool } = require('pg');
const cron = require('node-cron');

const config = {
  BOT_TOKEN: process.env.BOT_TOKEN,
  NEWS_CHANNEL_ID: process.env.NEWS_CHANNEL_ID,
  CHAT_CHANNEL_ID: process.env.CHAT_CHANNEL_ID,
  ADMIN_IDS: process.env.ADMIN_IDS ? process.env.ADMIN_IDS.split(',').map(id => parseInt(id.trim())) : [],
  AIRDROP_REWARD: 5000,
  AIRDROP_LIMIT: 20000,
  MESSAGE_INTERVAL: 10000,
  WARN_LIMIT: 3,
  REPORT_MUTE_LIMIT: 10,
  REPORT_BAN_LIMIT: 20,
  ALLOWED_DOMAINS: ['miningmai.com', 'www.miningmai.com', 't.me'],
};

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.DATABASE_URL ? { rejectUnauthorized: false } : false
});

const TEXTS = {
  en: {
    welcome: `ü§ñ *Welcome to MAI Project!*

I'm the MAI bot-moderator and assistant.

*üéÅ Airdrop: 5,000 MAI tokens!*
First ${config.AIRDROP_LIMIT.toLocaleString()} participants get rewards!

*üìù How to participate:*
1Ô∏è‚É£ /airdrop - Register
2Ô∏è‚É£ /wallet - Link Solana wallet
3Ô∏è‚É£ Stay subscribed until listing

*üí¨ Commands:*
/airdrop - Airdrop registration
/wallet - Link wallet
/status - Check status
/verify - Verify participation
/presale - Presale info
/nft - NFT levels info
/faq - Frequently asked questions
/rules - Chat rules
/lang - Change language
/help - Help

‚ö†Ô∏è *Important:* Subscribe to news channel and stay in chat!`,

    airdrop_already: `‚úÖ You are already registered!

üé´ Your position: *{position}* of ${config.AIRDROP_LIMIT.toLocaleString()}
üéÅ Reward: ${config.AIRDROP_REWARD.toLocaleString()} MAI

Use /status for details`,

    airdrop_no_news: `‚ùå Please subscribe to the news channel first!
üëâ @mai_news`,

    airdrop_no_chat: `‚ùå You must be a chat member!`,

    airdrop_limit: `‚ùå Unfortunately, all ${config.AIRDROP_LIMIT.toLocaleString()} spots are taken!

Follow the news for future airdrops!`,

    airdrop_success: `‚úÖ *Registration successful!*

üé´ Your position: *{position}* of ${config.AIRDROP_LIMIT.toLocaleString()}
üéÅ Reward: *${config.AIRDROP_REWARD.toLocaleString()} MAI*

‚ö†Ô∏è *Important conditions:*
‚Ä¢ Stay subscribed to channel and chat
‚Ä¢ Link Solana wallet: /wallet
‚Ä¢ Don't violate chat rules
‚Ä¢ Unsubscribe = airdrop exclusion

üìä Subscription check: daily at 00:00 UTC
üí∞ Token distribution: within 10 days after listing`,

    wallet_not_registered: `‚ùå Register for airdrop first!

Use command: /airdrop`,

    wallet_info: `üíº *Wallet Management*

{current}
üìù To link/change wallet:
/wallet YOUR_SOLANA_ADDRESS

Example:
/wallet 7xK3N9kZXxY2pQwM5vH8...`,

    wallet_invalid: `‚ùå Invalid Solana address format!

Solana address must be 32-44 characters (base58)`,

    wallet_success: `‚úÖ *Wallet successfully linked!*

üíº Address:
\`{wallet}\`

üéÅ ${config.AIRDROP_REWARD.toLocaleString()} MAI tokens will be sent to this address after listing!`,

    status_not_registered: `‚ùå You are not registered for airdrop!

Use /airdrop to register`,

    status_info: `üìä *Your Airdrop Status*

üë§ Username: @{username}
üé´ Position: *{position}* of ${config.AIRDROP_LIMIT.toLocaleString()}
üìÖ Registration: {date}

üì∫ Subscriptions:
{news_status} News channel
{chat_status} Project chat

üíº Wallet: {wallet_status}

‚ö†Ô∏è Warnings: {warnings}/${config.WARN_LIMIT}
üìä Reports: {reports}
üö´ Status: {status}

üéÅ *Reward: {reward} MAI*

{warnings_text}`,

    verify_success: `‚úÖ *VERIFICATION PASSED!*

You've completed all conditions:
‚úÖ Subscribed to news channel
‚úÖ Participating in chat
‚úÖ Wallet linked

üéÅ You will receive ${config.AIRDROP_REWARD.toLocaleString()} MAI after listing!`,

    verify_failed: `‚ö†Ô∏è *VERIFICATION FAILED*

Fix these issues:
{issues}`,

    rules: `üìã *MAI CHAT RULES*

‚úÖ *Allowed:*
‚Ä¢ Discussing MAI project
‚Ä¢ Questions about presale, tokens, airdrop
‚Ä¢ Constructive criticism
‚Ä¢ Crypto memes

‚ùå *FORBIDDEN:*
‚Ä¢ Spam and flood (> 1 msg/10 sec)
‚Ä¢ Advertising other projects
‚Ä¢ 18+ content
‚Ä¢ Insulting participants
‚Ä¢ Scam links
‚Ä¢ Publishing seed phrases/private keys
‚Ä¢ "DM me", "Write me in private"

‚ö†Ô∏è *Penalties:*
‚Ä¢ 1st violation: Warning
‚Ä¢ 2nd violation: Warning
‚Ä¢ 3rd violation: BAN

üìä *Report system:*
‚Ä¢ 10 reports = 24h mute
‚Ä¢ 20 reports = Permanent ban
‚Ä¢ Report: reply to message and /report

üéÅ *Airdrop 5,000 MAI:*
/airdrop - Registration (first ${config.AIRDROP_LIMIT.toLocaleString()})`,

    presale: `üí∞ *MAI PRESALE*

*Current Stage: 1*
üíµ Price: $0.0005
üìä Discount: 80% from listing
üéØ Allocation: 1.8% (126M MAI)

*How to buy:*
1. Visit https://miningmai.com
2. Connect wallet (Solana/ETH/BSC)
3. Choose amount
4. Confirm transaction

*NFT Bonuses:*
ü•â Bronze ($50-99): +5% mining
ü•à Silver ($100-199): +10% mining
ü•á Gold ($200-299): +15% mining
üíé Platinum ($300+): +20% mining

*Next stages:*
Stage 2: $0.0006 (76% discount)
Stage 3: $0.0007 (72% discount)
...
Final stage 14: $0.002 (20% discount)

üåê Website: https://miningmai.com`,

    nft: `üé® *MAI NFT LEVELS*

*ü•â BRONZE NFT*
Buy: $50-99 in Presale
Benefits:
‚Ä¢ Early mining access: +1 month
‚Ä¢ Early voting: 3 months
‚Ä¢ Mining bonus: +5% FOREVER

*ü•à SILVER NFT*
Buy: $100-199 in Presale
Benefits:
‚Ä¢ Early mining access: +2 months
‚Ä¢ Early voting: 6 months
‚Ä¢ Mining bonus: +10% FOREVER

*ü•á GOLD NFT*
Buy: $200-299 in Presale
Benefits:
‚Ä¢ Early mining access: +3 months
‚Ä¢ Early voting: 12 months
‚Ä¢ Mining bonus: +15% FOREVER

*üíé PLATINUM NFT*
Buy: $300+ in Presale
Benefits:
‚Ä¢ Early mining access: +3 months
‚Ä¢ Early voting: 12 months
‚Ä¢ Mining bonus: +20% FOREVER

üìà NFTs are tradeable on marketplaces!`,

    faq: `‚ùì *FREQUENTLY ASKED QUESTIONS*

*1. What is MAI?*
MAI is a decentralized AI platform combining blockchain and artificial intelligence. We create AI that belongs to the community.

*2. How to buy MAI tokens?*
Visit https://miningmai.com and participate in Presale. Connect your wallet and choose amount.

*3. What are NFT levels?*
Exclusive NFTs for Presale participants. Give permanent bonuses to mining (+5% to +20%) and early access.

*4. How does mining work?*
Use your computational power to mine MAI tokens and earn stable income. Launch: Q4 2026.

*5. When is listing?*
TGE (Token Generation Event) planned for Q4 2025 on DEX/CEX.

*6. What is staking?*
Stake MAI tokens and earn passive income with high APY. Available after launch.

*7. How to get airdrop?*
Use /airdrop, subscribe to channels, link wallet. First ${config.AIRDROP_LIMIT.toLocaleString()} participants get 5,000 MAI!

*8. Which wallet to use?*
Solana wallets: Phantom, Solflare, or any SPL-compatible wallet.

üåê More info: https://miningmai.com`,

    help: `üÜò *MAI BOT HELP*

*Airdrop:*
/airdrop - Registration
/wallet - Link wallet
/status - Check status
/verify - Verification

*Information:*
/presale - Presale stages
/nft - NFT levels
/faq - FAQ
/rules - Chat rules
/lang - Change language
/start - Welcome

*Moderation:*
/report - Report (reply to message)

üåê Website: https://miningmai.com
üì± Telegram: @mai_news`,

    lang_changed: `‚úÖ Language changed to English!`,
    report_self: `‚ùå You can't report yourself!`,
    report_admin: `‚ùå You can't report an administrator!`,
    report_success: `‚úÖ Report accepted. User has {reports} reports.`,
    report_no_reply: `‚ö†Ô∏è Reply to violator's message and type /report`,
    banned: `‚ùå You are banned and cannot participate.`,
    error: `‚ùå Error. Try again later.`,
  },
  ru: {
    welcome: `ü§ñ *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ MAI Project!*

–Ø –±–æ—Ç-–º–æ–¥–µ—Ä–∞—Ç–æ—Ä –∏ –ø–æ–º–æ—â–Ω–∏–∫ –ø—Ä–æ–µ–∫—Ç–∞ MAI.

*üéÅ Airdrop: 5,000 MAI —Ç–æ–∫–µ–Ω–æ–≤!*
–ü–µ—Ä–≤—ã–µ ${config.AIRDROP_LIMIT.toLocaleString()} —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø–æ–ª—É—á–∞—é—Ç –Ω–∞–≥—Ä–∞–¥—É!

*üìù –ö–∞–∫ —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å:*
1Ô∏è‚É£ /airdrop - –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è
2Ô∏è‚É£ /wallet - –ü—Ä–∏–≤—è–∑–∞—Ç—å Solana –∫–æ—à–µ–ª—ë–∫
3Ô∏è‚É£ –û—Å—Ç–∞–≤–∞—Ç—å—Å—è –ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–º –¥–æ –ª–∏—Å—Ç–∏–Ω–≥–∞

*üí¨ –ö–æ–º–∞–Ω–¥—ã:*
/airdrop - –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞ airdrop
/wallet - –ü—Ä–∏–≤—è–∑–∞—Ç—å –∫–æ—à–µ–ª—ë–∫
/status - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å
/verify - –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è —É—á–∞—Å—Ç–∏—è
/presale - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–µ—Å–µ–π–ª–µ
/nft - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ NFT —É—Ä–æ–≤–Ω—è—Ö
/faq - –ß–∞—Å—Ç—ã–µ –≤–æ–ø—Ä–æ—Å—ã
/rules - –ü—Ä–∞–≤–∏–ª–∞ —á–∞—Ç–∞
/lang - –°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫
/help - –ü–æ–º–æ—â—å

‚ö†Ô∏è *–í–∞–∂–Ω–æ:* –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª –Ω–æ–≤–æ—Å—Ç–µ–π –∏ –æ—Å—Ç–∞–≤–∞–π—Ç–µ—Å—å –≤ —á–∞—Ç–µ!`,

    airdrop_already: `‚úÖ –í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã!

üé´ –í–∞—à–∞ –ø–æ–∑–∏—Ü–∏—è: *{position}* –∏–∑ ${config.AIRDROP_LIMIT.toLocaleString()}
üéÅ –ù–∞–≥—Ä–∞–¥–∞: ${config.AIRDROP_REWARD.toLocaleString()} MAI

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /status –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π`,

    airdrop_no_news: `‚ùå –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª –Ω–æ–≤–æ—Å—Ç–µ–π!
üëâ @mai_news`,

    airdrop_no_chat: `‚ùå –í—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º —á–∞—Ç–∞!`,

    airdrop_limit: `‚ùå –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—Å–µ ${config.AIRDROP_LIMIT.toLocaleString()} –º–µ—Å—Ç –∑–∞–Ω—è—Ç—ã!

–°–ª–µ–¥–∏—Ç–µ –∑–∞ –Ω–æ–≤–æ—Å—Ç—è–º–∏ –æ —Å–ª–µ–¥—É—é—â–∏—Ö airdrop'–∞—Ö!`,

    airdrop_success: `‚úÖ *–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!*

üé´ –í–∞—à–∞ –ø–æ–∑–∏—Ü–∏—è: *{position}* –∏–∑ ${config.AIRDROP_LIMIT.toLocaleString()}
üéÅ –ù–∞–≥—Ä–∞–¥–∞: *${config.AIRDROP_REWARD.toLocaleString()} MAI*

‚ö†Ô∏è *–í–∞–∂–Ω—ã–µ —É—Å–ª–æ–≤–∏—è:*
‚Ä¢ –û—Å—Ç–∞–≤–∞–π—Ç–µ—Å—å –ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–º–∏ –Ω–∞ –∫–∞–Ω–∞–ª –∏ –≤ —á–∞—Ç–µ
‚Ä¢ –ü—Ä–∏–≤—è–∂–∏—Ç–µ Solana –∫–æ—à–µ–ª—ë–∫: /wallet
‚Ä¢ –ù–µ –Ω–∞—Ä—É—à–∞–π—Ç–µ –ø—Ä–∞–≤–∏–ª–∞ —á–∞—Ç–∞
‚Ä¢ –û—Ç–ø–∏—Å–∫–∞ = –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –∏–∑ airdrop

üìä –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏: –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 00:00 UTC
üí∞ –í—ã–¥–∞—á–∞ —Ç–æ–∫–µ–Ω–æ–≤: –≤ —Ç–µ—á–µ–Ω–∏–µ 10 –¥–Ω–µ–π –ø–æ—Å–ª–µ –ª–∏—Å—Ç–∏–Ω–≥–∞`,

    wallet_not_registered: `‚ùå –°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ airdrop!

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É: /airdrop`,

    wallet_info: `üíº *–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–æ–º*

{current}
üìù –ß—Ç–æ–±—ã –ø—Ä–∏–≤—è–∑–∞—Ç—å/–∏–∑–º–µ–Ω–∏—Ç—å –∫–æ—à–µ–ª—ë–∫:
/wallet –í–ê–®_SOLANA_–ê–î–†–ï–°

–ü—Ä–∏–º–µ—Ä:
/wallet 7xK3N9kZXxY2pQwM5vH8...`,

    wallet_invalid: `‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç Solana –∞–¥—Ä–µ—Å–∞!

Solana –∞–¥—Ä–µ—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 32-44 —Å–∏–º–≤–æ–ª–∞ (base58)`,

    wallet_success: `‚úÖ *–ö–æ—à–µ–ª—ë–∫ —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≤—è–∑–∞–Ω!*

üíº –ê–¥—Ä–µ—Å:
\`{wallet}\`

üéÅ –ù–∞ —ç—Ç–æ—Ç –∞–¥—Ä–µ—Å –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã ${config.AIRDROP_REWARD.toLocaleString()} MAI —Ç–æ–∫–µ–Ω–æ–≤ –ø–æ—Å–ª–µ –ª–∏—Å—Ç–∏–Ω–≥–∞!`,

    status_not_registered: `‚ùå –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ airdrop!

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /airdrop –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏`,

    status_info: `üìä *–í–∞—à —Å—Ç–∞—Ç—É—Å Airdrop*

üë§ Username: @{username}
üé´ –ü–æ–∑–∏—Ü–∏—è: *{position}* –∏–∑ ${config.AIRDROP_LIMIT.toLocaleString()}
üìÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è: {date}

üì∫ –ü–æ–¥–ø–∏—Å–∫–∏:
{news_status} –ö–∞–Ω–∞–ª –Ω–æ–≤–æ—Å—Ç–µ–π
{chat_status} –ß–∞—Ç –ø—Ä–æ–µ–∫—Ç–∞

üíº –ö–æ—à–µ–ª—ë–∫: {wallet_status}

‚ö†Ô∏è –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è: {warnings}/${config.WARN_LIMIT}
üìä –ñ–∞–ª–æ–±—ã: {reports}
üö´ –°—Ç–∞—Ç—É—Å: {status}

üéÅ *–ù–∞–≥—Ä–∞–¥–∞: {reward} MAI*

{warnings_text}`,

    verify_success: `‚úÖ *–í–ï–†–ò–§–ò–ö–ê–¶–ò–Ø –ü–†–û–ô–î–ï–ù–ê!*

–í—ã –≤—ã–ø–æ–ª–Ω–∏–ª–∏ –≤—Å–µ —É—Å–ª–æ–≤–∏—è:
‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª –Ω–æ–≤–æ—Å—Ç–µ–π
‚úÖ –£—á–∞—Å—Ç–∏–µ –≤ —á–∞—Ç–µ
‚úÖ –ö–æ—à–µ–ª—ë–∫ –ø—Ä–∏–≤—è–∑–∞–Ω

üéÅ –í—ã –ø–æ–ª—É—á–∏—Ç–µ ${config.AIRDROP_REWARD.toLocaleString()} MAI –ø–æ—Å–ª–µ –ª–∏—Å—Ç–∏–Ω–≥–∞!`,

    verify_failed: `‚ö†Ô∏è *–í–ï–†–ò–§–ò–ö–ê–¶–ò–Ø –ù–ï –ü–†–û–ô–î–ï–ù–ê*

–£—Å—Ç—Ä–∞–Ω–∏—Ç–µ –ø—Ä–æ–±–ª–µ–º—ã:
{issues}`,

    rules: `üìã *–ü–†–ê–í–ò–õ–ê –ß–ê–¢–ê MAI*

‚úÖ *–†–∞–∑—Ä–µ—à–µ–Ω–æ:*
‚Ä¢ –û–±—Å—É–∂–¥–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ MAI
‚Ä¢ –í–æ–ø—Ä–æ—Å—ã –æ –ø—Ä–µ—Å–µ–π–ª–µ, —Ç–æ–∫–µ–Ω–∞—Ö, airdrop
‚Ä¢ –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–∏–≤–Ω–∞—è –∫—Ä–∏—Ç–∏–∫–∞
‚Ä¢ –ú–µ–º—ã –ø—Ä–æ –∫—Ä–∏–ø—Ç—É

‚ùå *–ó–ê–ü–†–ï–©–ï–ù–û:*
‚Ä¢ –°–ø–∞–º –∏ —Ñ–ª—É–¥ (> 1 —Å–æ–æ–±—â–µ–Ω–∏–µ/10 —Å–µ–∫)
‚Ä¢ –†–µ–∫–ª–∞–º–∞ –¥—Ä—É–≥–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤
‚Ä¢ 18+ –∫–æ–Ω—Ç–µ–Ω—Ç
‚Ä¢ –û—Å–∫–æ—Ä–±–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
‚Ä¢ –°–∫–∞–º-—Å—Å—ã–ª–∫–∏
‚Ä¢ –ü—É–±–ª–∏–∫–∞—Ü–∏—è seed —Ñ—Ä–∞–∑/–ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö –∫–ª—é—á–µ–π
‚Ä¢ "DM me", "Write me in private"

‚ö†Ô∏è *–ù–∞–∫–∞–∑–∞–Ω–∏—è:*
‚Ä¢ 1-–µ –Ω–∞—Ä—É—à–µ–Ω–∏–µ: –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
‚Ä¢ 2-–µ –Ω–∞—Ä—É—à–µ–Ω–∏–µ: –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
‚Ä¢ 3-–µ –Ω–∞—Ä—É—à–µ–Ω–∏–µ: –ë–ê–ù

üìä *–°–∏—Å—Ç–µ–º–∞ –∂–∞–ª–æ–±:*
‚Ä¢ 10 –∂–∞–ª–æ–± = –ú—É—Ç 24 —á–∞—Å–∞
‚Ä¢ 20 –∂–∞–ª–æ–± = –ü–µ—Ä–º–∞–Ω–µ–Ω—Ç–Ω—ã–π –±–∞–Ω
‚Ä¢ –ñ–∞–ª–æ–±–∞: –æ—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ /report

üéÅ *Airdrop 5,000 MAI:*
/airdrop - –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è (–ø–µ—Ä–≤—ã–µ ${config.AIRDROP_LIMIT.toLocaleString()})`,

    presale: `üí∞ *MAI PRESALE*

*–¢–µ–∫—É—â–∏–π —ç—Ç–∞–ø: 1*
üíµ –¶–µ–Ω–∞: $0.0005
üìä –°–∫–∏–¥–∫–∞: 80% –æ—Ç –ª–∏—Å—Ç–∏–Ω–≥–∞
üéØ –ê–ª–ª–æ–∫–∞—Ü–∏—è: 1.8% (126M MAI)

*–ö–∞–∫ –∫—É–ø–∏—Ç—å:*
1. –ó–∞–π–¥–∏—Ç–µ –Ω–∞ https://miningmai.com
2. –ü–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ—à–µ–ª—ë–∫ (Solana/ETH/BSC)
3. –í—ã–±–µ—Ä–∏—Ç–µ —Å—É–º–º—É
4. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é

*NFT –±–æ–Ω—É—Å—ã:*
ü•â Bronze ($50-99): +5% –º–∞–π–Ω–∏–Ω–≥
ü•à Silver ($100-199): +10% –º–∞–π–Ω–∏–Ω–≥
ü•á Gold ($200-299): +15% –º–∞–π–Ω–∏–Ω–≥
üíé Platinum ($300+): +20% –º–∞–π–Ω–∏–Ω–≥

*–°–ª–µ–¥—É—é—â–∏–µ —ç—Ç–∞–ø—ã:*
–≠—Ç–∞–ø 2: $0.0006 (76% —Å–∫–∏–¥–∫–∞)
–≠—Ç–∞–ø 3: $0.0007 (72% —Å–∫–∏–¥–∫–∞)
...
–§–∏–Ω–∞–ª—å–Ω—ã–π —ç—Ç–∞–ø 14: $0.002 (20% —Å–∫–∏–¥–∫–∞)

üåê –°–∞–π—Ç: https://miningmai.com`,

    nft: `üé® *MAI NFT –£–†–û–í–ù–ò*

*ü•â BRONZE NFT*
–ü–æ–∫—É–ø–∫–∞: $50-99 –≤ Presale
–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:
‚Ä¢ –†–∞–Ω–Ω–∏–π –¥–æ—Å—Ç—É–ø –∫ –º–∞–π–Ω–∏–Ω–≥—É: +1 –º–µ—Å—è—Ü
‚Ä¢ –†–∞–Ω–Ω–µ–µ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ: 3 –º–µ—Å—è—Ü–∞
‚Ä¢ –ë–æ–Ω—É—Å –º–∞–π–Ω–∏–Ω–≥–∞: +5% –ù–ê–í–°–ï–ì–î–ê

*ü•à SILVER NFT*
–ü–æ–∫—É–ø–∫–∞: $100-199 –≤ Presale
–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:
‚Ä¢ –†–∞–Ω–Ω–∏–π –¥–æ—Å—Ç—É–ø –∫ –º–∞–π–Ω–∏–Ω–≥—É: +2 –º–µ—Å—è—Ü–∞
‚Ä¢ –†–∞–Ω–Ω–µ–µ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ: 6 –º–µ—Å—è—Ü–µ–≤
‚Ä¢ –ë–æ–Ω—É—Å –º–∞–π–Ω–∏–Ω–≥–∞: +10% –ù–ê–í–°–ï–ì–î–ê

*ü•á GOLD NFT*
–ü–æ–∫—É–ø–∫–∞: $200-299 –≤ Presale
–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:
‚Ä¢ –†–∞–Ω–Ω–∏–π –¥–æ—Å—Ç—É–ø –∫ –º–∞–π–Ω–∏–Ω–≥—É: +3 –º–µ—Å—è—Ü–∞
‚Ä¢ –†–∞–Ω–Ω–µ–µ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ: 12 –º–µ—Å—è—Ü–µ–≤
‚Ä¢ –ë–æ–Ω—É—Å –º–∞–π–Ω–∏–Ω–≥–∞: +15% –ù–ê–í–°–ï–ì–î–ê

*üíé PLATINUM NFT*
–ü–æ–∫—É–ø–∫–∞: $300+ –≤ Presale
–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:
‚Ä¢ –†–∞–Ω–Ω–∏–π –¥–æ—Å—Ç—É–ø –∫ –º–∞–π–Ω–∏–Ω–≥—É: +3 –º–µ—Å—è—Ü–∞
‚Ä¢ –†–∞–Ω–Ω–µ–µ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ: 12 –º–µ—Å—è—Ü–µ–≤
‚Ä¢ –ë–æ–Ω—É—Å –º–∞–π–Ω–∏–Ω–≥–∞: +20% –ù–ê–í–°–ï–ì–î–ê

üìà NFT –º–æ–∂–Ω–æ –ø—Ä–æ–¥–∞–≤–∞—Ç—å –Ω–∞ –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–∞—Ö!`,

    faq: `‚ùì *–ß–ê–°–¢–´–ï –í–û–ü–†–û–°–´*

*1. –ß—Ç–æ —Ç–∞–∫–æ–µ MAI?*
MAI ‚Äî –¥–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è AI –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞, –æ–±—ä–µ–¥–∏–Ω—è—é—â–∞—è –±–ª–æ–∫—á–µ–π–Ω –∏ –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç. –ú—ã —Å–æ–∑–¥–∞–µ–º –ò–ò, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —Å–æ–æ–±—â–µ—Å—Ç–≤—É.

*2. –ö–∞–∫ –∫—É–ø–∏—Ç—å MAI —Ç–æ–∫–µ–Ω—ã?*
–ó–∞–π–¥–∏—Ç–µ –Ω–∞ https://miningmai.com –∏ —É—á–∞—Å—Ç–≤—É–π—Ç–µ –≤ Presale. –ü–æ–¥–∫–ª—é—á–∏—Ç–µ –∫–æ—à–µ–ª—ë–∫ –∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Å—É–º–º—É.

*3. –ß—Ç–æ —Ç–∞–∫–æ–µ NFT —É—Ä–æ–≤–Ω–∏?*
–≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–µ NFT –¥–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ Presale. –î–∞—é—Ç –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–µ –±–æ–Ω—É—Å—ã –∫ –º–∞–π–Ω–∏–Ω–≥—É (+5% –¥–æ +20%) –∏ —Ä–∞–Ω–Ω–∏–π –¥–æ—Å—Ç—É–ø.

*4. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –º–∞–π–Ω–∏–Ω–≥?*
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã–µ –º–æ—â–Ω–æ—Å—Ç–∏ –¥–ª—è –º–∞–π–Ω–∏–Ω–≥–∞ MAI —Ç–æ–∫–µ–Ω–æ–≤ –∏ –ø–æ–ª—É—á–∞–π—Ç–µ —Å—Ç–∞–±–∏–ª—å–Ω—ã–π –¥–æ—Ö–æ–¥. –ó–∞–ø—É—Å–∫: Q4 2026.

*5. –ö–æ–≥–¥–∞ –ª–∏—Å—Ç–∏–Ω–≥?*
TGE (Token Generation Event) –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω –Ω–∞ Q4 2025 –Ω–∞ DEX/CEX.

*6. –ß—Ç–æ —Ç–∞–∫–æ–µ —Å—Ç–µ–π–∫–∏–Ω–≥?*
–ó–∞—Å—Ç–µ–π–∫–∞–π—Ç–µ MAI —Ç–æ–∫–µ–Ω—ã –∏ –ø–æ–ª—É—á–∞–π—Ç–µ –ø–∞—Å—Å–∏–≤–Ω—ã–π –¥–æ—Ö–æ–¥ —Å –≤—ã—Å–æ–∫–∏–º APY. –î–æ—Å—Ç—É–ø–µ–Ω –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞.

*7. –ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å airdrop?*
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /airdrop, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã, –ø—Ä–∏–≤—è–∂–∏—Ç–µ –∫–æ—à–µ–ª—ë–∫. –ü–µ—Ä–≤—ã–µ ${config.AIRDROP_LIMIT.toLocaleString()} —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø–æ–ª—É—á–∞—Ç 5,000 MAI!

*8. –ö–∞–∫–æ–π –∫–æ—à–µ–ª—ë–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å?*
Solana –∫–æ—à–µ–ª—å–∫–∏: Phantom, Solflare –∏–ª–∏ –ª—é–±–æ–π SPL-—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π –∫–æ—à–µ–ª—ë–∫.

üåê –ë–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏: https://miningmai.com`,

    help: `üÜò *–ü–û–ú–û–©–¨ MAI BOT*

*Airdrop:*
/airdrop - –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
/wallet - –ü—Ä–∏–≤—è–∑–∞—Ç—å –∫–æ—à–µ–ª—ë–∫
/status - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å
/verify - –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è

*–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:*
/presale - –≠—Ç–∞–ø—ã –ø—Ä–µ—Å–µ–π–ª–∞
/nft - NFT —É—Ä–æ–≤–Ω–∏
/faq - –ß–∞—Å—Ç—ã–µ –≤–æ–ø—Ä–æ—Å—ã
/rules - –ü—Ä–∞–≤–∏–ª–∞ —á–∞—Ç–∞
/lang - –°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫
/start - –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ

*–ú–æ–¥–µ—Ä–∞—Ü–∏—è:*
/report - –ü–æ–∂–∞–ª–æ–≤–∞—Ç—å—Å—è (reply –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ)

üåê –°–∞–π—Ç: https://miningmai.com
üì± Telegram: @mai_news`,

    lang_changed: `‚úÖ –Ø–∑—ã–∫ –∏–∑–º–µ–Ω—ë–Ω –Ω–∞ –†—É—Å—Å–∫–∏–π!`,
    report_self: `‚ùå –ù–µ–ª—å–∑—è –∂–∞–ª–æ–≤–∞—Ç—å—Å—è –Ω–∞ —Å–∞–º–æ–≥–æ —Å–µ–±—è!`,
    report_admin: `‚ùå –ù–µ–ª—å–∑—è –∂–∞–ª–æ–≤–∞—Ç—å—Å—è –Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞!`,
    report_success: `‚úÖ –ñ–∞–ª–æ–±–∞ –ø—Ä–∏–Ω—è—Ç–∞. –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {reports} –∂–∞–ª–æ–±.`,
    report_no_reply: `‚ö†Ô∏è –û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞—Ä—É—à–∏—Ç–µ–ª—è –∏ –Ω–∞–ø–∏—à–∏—Ç–µ /report`,
    banned: `‚ùå –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –∏ –Ω–µ –º–æ–∂–µ—Ç–µ —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å.`,
    error: `‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.`,
  }
};

async function initDatabase() {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    await client.query(`
      CREATE TABLE IF NOT EXISTS telegram_users (
        id SERIAL PRIMARY KEY,
        telegram_id BIGINT UNIQUE NOT NULL,
        username VARCHAR(255),
        first_name VARCHAR(255),
        language_code VARCHAR(10) DEFAULT 'en',
        wallet_address VARCHAR(44),
        registered_at TIMESTAMP DEFAULT NOW(),
        is_subscribed_news BOOLEAN DEFAULT true,
        is_subscribed_chat BOOLEAN DEFAULT true,
        last_check TIMESTAMP DEFAULT NOW(),
        warnings INT DEFAULT 0,
        reports_received INT DEFAULT 0,
        banned BOOLEAN DEFAULT false,
        muted_until TIMESTAMP NULL,
        reward_amount INT DEFAULT 5000,
        claimed BOOLEAN DEFAULT false,
        position INT
      )
    `);
    
    await client.query(`
      CREATE TABLE IF NOT EXISTS user_messages (
        id SERIAL PRIMARY KEY,
        user_id BIGINT NOT NULL,
        message_time TIMESTAMP DEFAULT NOW()
      )
    `);
    
    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_telegram_id ON telegram_users(telegram_id)
    `);
    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_wallet ON telegram_users(wallet_address)
    `);
    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_position ON telegram_users(position)
    `);
    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_user_messages ON user_messages(user_id, message_time)
    `);
    
    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

function getLang(ctx) {
  return ctx.session?.lang || ctx.from?.language_code?.startsWith('ru') ? 'ru' : 'en';
}

function t(ctx, key, replacements = {}) {
  const lang = getLang(ctx);
  let text = TEXTS[lang]?.[key] || TEXTS.en[key] || key;
  Object.entries(replacements).forEach(([k, v]) => {
    text = text.replace(new RegExp(`{${k}}`, 'g'), v);
  });
  return text;
}

async function checkSubscription(bot, channelId, userId) {
  try {
    const member = await bot.telegram.getChatMember(channelId, userId);
    return ['member', 'administrator', 'creator'].includes(member.status);
  } catch {
    return false;
  }
}

function isValidSolanaAddress(address) {
  return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
}

function containsBadContent(text) {
  const patterns = [
    /casino/i, /porn/i, /18\+/i, /xxx/i,
    /buy.*get.*free/i, /send.*receive/i,
    /seed\s*phrase/i, /private\s*key/i, /recovery\s*phrase/i,
    /dm\s*me/i, /write\s*me/i, /contact\s*admin/i,
    /pump/i, /dump/i, /rug/i, /scam/i
  ];
  return patterns.some(p => p.test(text));
}

function containsSpamLinks(text) {
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  const urls = text.match(urlRegex) || [];
  for (const url of urls) {
    if (!config.ALLOWED_DOMAINS.some(d => url.includes(d))) return true;
  }
  return false;
}

async function checkFlood(userId) {
  try {
    const tenSecondsAgo = new Date(Date.now() - config.MESSAGE_INTERVAL);
    const result = await pool.query(
      'SELECT COUNT(*) FROM user_messages WHERE user_id = $1 AND message_time > $2',
      [userId, tenSecondsAgo]
    );
    const count = parseInt(result.rows[0].count);
    
    await pool.query(
      'INSERT INTO user_messages (user_id, message_time) VALUES ($1, NOW())',
      [userId]
    );
    
    await pool.query(
      'DELETE FROM user_messages WHERE message_time < $1',
      [new Date(Date.now() - 60000)]
    );
    
    return count > 0;
  } catch {
    return false;
  }
}

async function registerUser(userId, username, firstName, langCode) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    const countResult = await client.query(
      'SELECT COUNT(*) FROM telegram_users WHERE position IS NOT NULL'
    );
    const currentCount = parseInt(countResult.rows[0].count);
    
    if (currentCount >= config.AIRDROP_LIMIT) {
      await client.query('ROLLBACK');
      return { success: false, reason: 'limit_reached' };
    }
    
    const result = await client.query(
      `INSERT INTO telegram_users (telegram_id, username, first_name, language_code, position)
       VALUES ($1, $2, $3, $4, $5)
       ON CONFLICT (telegram_id) 
       DO UPDATE SET username = $2, first_name = $3, language_code = $4
       RETURNING *`,
      [userId, username, firstName, langCode, currentCount + 1]
    );
    
    await client.query('COMMIT');
    return { success: true, user: result.rows[0] };
  } catch (error) {
    await client.query('ROLLBACK');
    return { success: false, reason: 'database_error' };
  } finally {
    client.release();
  }
}

async function updateWallet(userId, walletAddress) {
  try {
    await pool.query(
      'UPDATE telegram_users SET wallet_address = $1 WHERE telegram_id = $2',
      [walletAddress, userId]
    );
    return true;
  } catch {
    return false;
  }
}

async function getUserStatus(userId) {
  try {
    const result = await pool.query(
      'SELECT * FROM telegram_users WHERE telegram_id = $1',
      [userId]
    );
    return result.rows[0] || null;
  } catch {
    return null;
  }
}

async function updateSubscription(userId, newsSubscribed, chatSubscribed) {
  try {
    await pool.query(
      `UPDATE telegram_users 
       SET is_subscribed_news = $1, is_subscribed_chat = $2, last_check = NOW()
       WHERE telegram_id = $3`,
      [newsSubscribed, chatSubscribed, userId]
    );
  } catch {}
}

async function addWarning(userId) {
  try {
    const result = await pool.query(
      `UPDATE telegram_users SET warnings = warnings + 1
       WHERE telegram_id = $1 RETURNING warnings`,
      [userId]
    );
    return result.rows[0]?.warnings || 0;
  } catch {
    return 0;
  }
}

async function addReport(userId) {
  try {
    const result = await pool.query(
      `UPDATE telegram_users SET reports_received = reports_received + 1
       WHERE telegram_id = $1 RETURNING reports_received`,
      [userId]
    );
    return result.rows[0]?.reports_received || 0;
  } catch {
    return 0;
  }
}

async function banUser(userId) {
  try {
    await pool.query(
      'UPDATE telegram_users SET banned = true WHERE telegram_id = $1',
      [userId]
    );
  } catch {}
}

async function muteUser(userId, hours = 24) {
  try {
    const muteUntil = new Date(Date.now() + hours * 60 * 60 * 1000);
    await pool.query(
      'UPDATE telegram_users SET muted_until = $1 WHERE telegram_id = $2',
      [muteUntil, userId]
    );
  } catch {}
}

async function updateLanguage(userId, langCode) {
  try {
    await pool.query(
      'UPDATE telegram_users SET language_code = $1 WHERE telegram_id = $2',
      [langCode, userId]
    );
  } catch {}
}

const bot = new Telegraf(config.BOT_TOKEN);

bot.use(async (ctx, next) => {
  const user = await getUserStatus(ctx.from?.id);
  ctx.session = { lang: user?.language_code || (ctx.from?.language_code?.startsWith('ru') ? 'ru' : 'en') };
  return next();
});

initDatabase().catch(() => {});

bot.start(async (ctx) => {
  await ctx.reply(t(ctx, 'welcome'), { parse_mode: 'Markdown' });
});

bot.command('airdrop', async (ctx) => {
  const userId = ctx.from.id;
  const username = ctx.from.username || 'no_username';
  const firstName = ctx.from.first_name;
  const langCode = getLang(ctx);
  
  try {
    const userStatus = await getUserStatus(userId);
    
    if (userStatus?.banned) {
      return ctx.reply(t(ctx, 'banned'));
    }
    
    if (userStatus?.position) {
      return ctx.reply(
        t(ctx, 'airdrop_already', { position: userStatus.position }),
        { parse_mode: 'Markdown' }
      );
    }
    
    const newsSubscribed = await checkSubscription(bot, config.NEWS_CHANNEL_ID, userId);
    const chatSubscribed = await checkSubscription(bot, config.CHAT_CHANNEL_ID, userId);
    
    if (!newsSubscribed) {
      return ctx.reply(t(ctx, 'airdrop_no_news'), { parse_mode: 'Markdown' });
    }
    
    if (!chatSubscribed) {
      return ctx.reply(t(ctx, 'airdrop_no_chat'));
    }
    
    const registration = await registerUser(userId, username, firstName, langCode);
    
    if (!registration.success) {
      if (registration.reason === 'limit_reached') {
        return ctx.reply(t(ctx, 'airdrop_limit'));
      }
      return ctx.reply(t(ctx, 'error'));
    }
    
    await ctx.reply(
      t(ctx, 'airdrop_success', { position: registration.user.position }),
      { parse_mode: 'Markdown' }
    );
  } catch {
    ctx.reply(t(ctx, 'error'));
  }
});

bot.command('wallet', async (ctx) => {
  const userId = ctx.from.id;
  const userStatus = await getUserStatus(userId);
  
  if (!userStatus?.position) {
    return ctx.reply(t(ctx, 'wallet_not_registered'));
  }
  
  const args = ctx.message.text.split(' ');
  
  if (args.length < 2) {
    const current = userStatus.wallet_address 
      ? `‚úÖ Current wallet:\n\`${userStatus.wallet_address}\`\n\n`
      : '‚ùå Wallet not linked\n\n';
    return ctx.reply(
      t(ctx, 'wallet_info', { current }),
      { parse_mode: 'Markdown' }
    );
  }
  
  const walletAddress = args[1].trim();
  
  if (!isValidSolanaAddress(walletAddress)) {
    return ctx.reply(t(ctx, 'wallet_invalid'));
  }
  
  const updated = await updateWallet(userId, walletAddress);
  
  if (updated) {
    await ctx.reply(
      t(ctx, 'wallet_success', { wallet: walletAddress }),
      { parse_mode: 'Markdown' }
    );
  } else {
    ctx.reply(t(ctx, 'error'));
  }
});

bot.command('status', async (ctx) => {
  const userId = ctx.from.id;
  
  try {
    const userStatus = await getUserStatus(userId);
    
    if (!userStatus?.position) {
      return ctx.reply(t(ctx, 'status_not_registered'));
    }
    
    const newsSubscribed = await checkSubscription(bot, config.NEWS_CHANNEL_ID, userId);
    const chatSubscribed = await checkSubscription(bot, config.CHAT_CHANNEL_ID, userId);
    
    if (newsSubscribed !== userStatus.is_subscribed_news || chatSubscribed !== userStatus.is_subscribed_chat) {
      await updateSubscription(userId, newsSubscribed, chatSubscribed);
    }
    
    const rewardAmount = (newsSubscribed && chatSubscribed && !userStatus.banned)
      ? config.AIRDROP_REWARD.toLocaleString()
      : '0';
    
    const statusText = (newsSubscribed && chatSubscribed && !userStatus.banned) ? '‚úÖ Active' : '‚ùå Inactive';
    const walletStatus = userStatus.wallet_address ? `\`${userStatus.wallet_address}\`` : '‚ùå Not linked';
    const warningsText = (!newsSubscribed || !chatSubscribed) ? '\n‚ö†Ô∏è Subscribe to all channels!' : '';
    
    await ctx.reply(
      t(ctx, 'status_info', {
        username: userStatus.username,
        position: userStatus.position,
        date: new Date(userStatus.registered_at).toLocaleDateString(),
        news_status: newsSubscribed ? '‚úÖ' : '‚ùå',
        chat_status: chatSubscribed ? '‚úÖ' : '‚ùå',
        wallet_status: walletStatus,
        warnings: userStatus.warnings,
        reports: userStatus.reports_received,
        status: statusText,
        reward: rewardAmount,
        warnings_text: warningsText
      }),
      { parse_mode: 'Markdown' }
    );
  } catch {
    ctx.reply(t(ctx, 'error'));
  }
});

bot.command('verify', async (ctx) => {
  const userId = ctx.from.id;
  const userStatus = await getUserStatus(userId);
  
  if (!userStatus?.position) {
    return ctx.reply(t(ctx, 'status_not_registered'));
  }
  
  const newsSubscribed = await checkSubscription(bot, config.NEWS_CHANNEL_ID, userId);
  const chatSubscribed = await checkSubscription(bot, config.CHAT_CHANNEL_ID, userId);
  const hasWallet = !!userStatus.wallet_address;
  const isVerified = newsSubscribed && chatSubscribed && hasWallet && !userStatus.banned;
  
  if (isVerified) {
    await ctx.reply(t(ctx, 'verify_success'), { parse_mode: 'Markdown' });
  } else {
    let issues = [];
    if (!newsSubscribed) issues.push('‚ùå Subscribe to news channel');
    if (!chatSubscribed) issues.push('‚ùå Join chat');
    if (!hasWallet) issues.push('‚ùå Link wallet (/wallet)');
    if (userStatus.banned) issues.push('‚ùå You are banned');
    
    await ctx.reply(
      t(ctx, 'verify_failed', { issues: issues.join('\n') }),
      { parse_mode: 'Markdown' }
    );
  }
});

bot.command('rules', async (ctx) => {
  await ctx.reply(t(ctx, 'rules'), { parse_mode: 'Markdown' });
});

bot.command('presale', async (ctx) => {
  await ctx.reply(t(ctx, 'presale'), { parse_mode: 'Markdown' });
});

bot.command('nft', async (ctx) => {
  await ctx.reply(t(ctx, 'nft'), { parse_mode: 'Markdown' });
});

bot.command('faq', async (ctx) => {
  await ctx.reply(t(ctx, 'faq'), { parse_mode: 'Markdown' });
});

bot.command('help', async (ctx) => {
  await ctx.reply(t(ctx, 'help'), { parse_mode: 'Markdown' });
});

bot.command(['lang', 'language'], async (ctx) => {
  const currentLang = getLang(ctx);
  const newLang = currentLang === 'ru' ? 'en' : 'ru';
  
  await updateLanguage(ctx.from.id, newLang);
  ctx.session.lang = newLang;
  
  await ctx.reply(t(ctx, 'lang_changed'));
});

bot.command('report', async (ctx) => {
  if (!ctx.message.reply_to_message) {
    return ctx.reply(t(ctx, 'report_no_reply'));
  }
  
  const reportedUserId = ctx.message.reply_to_message.from.id;
  const reporterId = ctx.from.id;
  
  if (reportedUserId === reporterId) {
    return ctx.reply(t(ctx, 'report_self'));
  }
  
  if (config.ADMIN_IDS.includes(reportedUserId)) {
    return ctx.reply(t(ctx, 'report_admin'));
  }
  
  const reports = await addReport(reportedUserId);
  
  await ctx.reply(t(ctx, 'report_success', { reports }));
  
  if (reports >= config.REPORT_BAN_LIMIT) {
    await banUser(reportedUserId);
    await ctx.telegram.banChatMember(ctx.chat.id, reportedUserId);
  } else if (reports >= config.REPORT_MUTE_LIMIT) {
    await muteUser(reportedUserId, 24);
    await ctx.telegram.restrictChatMember(ctx.chat.id, reportedUserId, {
      until_date: Math.floor(Date.now() / 1000) + 86400,
      permissions: { can_send_messages: false }
    });
  }
});

bot.command('stats', async (ctx) => {
  if (!config.ADMIN_IDS.includes(ctx.from.id)) return;
  
  try {
    const stats = await pool.query(`
      SELECT 
        COUNT(*) as total,
        COUNT(*) FILTER (WHERE is_subscribed_news AND is_subscribed_chat) as active,
        COUNT(*) FILTER (WHERE wallet_address IS NOT NULL) as with_wallet,
        COUNT(*) FILTER (WHERE banned = true) as banned
      FROM telegram_users WHERE position IS NOT NULL
    `);
    
    const s = stats.rows[0];
    
    await ctx.reply(
      `üìä *Airdrop Statistics*\n\n` +
      `üë• Total registered: ${s.total}/${config.AIRDROP_LIMIT}\n` +
      `‚úÖ Active participants: ${s.active}\n` +
      `üíº With wallets: ${s.with_wallet}\n` +
      `üö´ Banned: ${s.banned}\n\n` +
      `üí∞ Total to distribute: ${(s.active * config.AIRDROP_REWARD).toLocaleString()} MAI`,
      { parse_mode: 'Markdown' }
    );
  } catch {
    ctx.reply('‚ùå Error getting statistics');
  }
});

bot.command('winners', async (ctx) => {
  if (!config.ADMIN_IDS.includes(ctx.from.id)) return;
  
  try {
    const winners = await pool.query(`
      SELECT telegram_id, username, wallet_address, position
      FROM telegram_users
      WHERE is_subscribed_news = true 
        AND is_subscribed_chat = true
        AND wallet_address IS NOT NULL
        AND banned = false
        AND position IS NOT NULL
      ORDER BY position ASC
    `);
    
    let csv = 'Position,Telegram_ID,Username,Wallet_Address,Reward\n';
    winners.rows.forEach(w => {
      csv += `${w.position},${w.telegram_id},@${w.username},${w.wallet_address},${config.AIRDROP_REWARD}\n`;
    });
    
    await ctx.replyWithDocument({
      source: Buffer.from(csv),
      filename: `mai_airdrop_winners_${Date.now()}.csv`
    });
    
    await ctx.reply(
      `‚úÖ Exported ${winners.rows.length} winners\n` +
      `üí∞ Total to distribute: ${(winners.rows.length * config.AIRDROP_REWARD).toLocaleString()} MAI`
    );
  } catch {
    ctx.reply('‚ùå Export error');
  }
});

bot.on(message('text'), async (ctx) => {
  if (config.ADMIN_IDS.includes(ctx.from.id)) return;
  
  const userId = ctx.from.id;
  const text = ctx.message.text;
  
  try {
    const userStatus = await getUserStatus(userId);
    
    if (userStatus?.banned) {
      await ctx.deleteMessage();
      return;
    }
    
    if (userStatus?.muted_until && new Date() < new Date(userStatus.muted_until)) {
      await ctx.deleteMessage();
      return;
    }
    
    const isFlood = await checkFlood(userId);
    if (isFlood) {
      await ctx.deleteMessage();
      const warnings = await addWarning(userId);
      
      if (warnings >= config.WARN_LIMIT) {
        await banUser(userId);
        await ctx.telegram.banChatMember(ctx.chat.id, userId);
        return;
      }
      
      return ctx.reply(
        `‚ö†Ô∏è @${ctx.from.username || ctx.from.first_name}, no flooding! ` +
        `Limit: 1 message/10 sec. Warning ${warnings}/${config.WARN_LIMIT}`,
        { reply_to_message_id: ctx.message.message_id }
      );
    }
    
    if (containsBadContent(text)) {
      await ctx.deleteMessage();
      const warnings = await addWarning(userId);
      
      if (warnings >= config.WARN_LIMIT) {
        await banUser(userId);
        await ctx.telegram.banChatMember(ctx.chat.id, userId);
        return;
      }
      
      return ctx.reply(
        `‚ö†Ô∏è Message deleted! Forbidden content. Warning ${warnings}/${config.WARN_LIMIT}`
      );
    }
    
    if (containsSpamLinks(text)) {
      await ctx.deleteMessage();
      const warnings = await addWarning(userId);
      
      if (warnings >= config.WARN_LIMIT) {
        await banUser(userId);
        await ctx.telegram.banChatMember(ctx.chat.id, userId);
        return;
      }
      
      return ctx.reply(
        `‚ö†Ô∏è External links forbidden! Warning ${warnings}/${config.WARN_LIMIT}`
      );
    }
  } catch {}
});

cron.schedule('0 0 * * *', async () => {
  try {
    const users = await pool.query(
      'SELECT telegram_id FROM telegram_users WHERE position IS NOT NULL AND banned = false'
    );
    
    for (const user of users.rows) {
      try {
        const newsSubscribed = await checkSubscription(bot, config.NEWS_CHANNEL_ID, user.telegram_id);
        const chatSubscribed = await checkSubscription(bot, config.CHAT_CHANNEL_ID, user.telegram_id);
        
        if (!newsSubscribed || !chatSubscribed) {
          await updateSubscription(user.telegram_id, newsSubscribed, chatSubscribed);
        }
      } catch {}
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  } catch {}
});

bot.launch({
  dropPendingUpdates: true
}).then(() => {
  if (config.ADMIN_IDS[0]) {
    bot.telegram.sendMessage(config.ADMIN_IDS[0], '‚úÖ MAI Bot v2.0 started successfully!').catch(() => {});
  }
}).catch(() => {
  process.exit(1);
});

process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));